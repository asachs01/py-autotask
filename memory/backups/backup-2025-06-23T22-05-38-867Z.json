{
  "timestamp": "2025-06-23T22:05:38.867Z",
  "version": "1.0",
  "entries": [
    {
      "id": "entry_mc9n85km_tmrua3wlz",
      "key": "swarm-auto-centralized-1750716058662/analyst/analysis_overview",
      "value": "\"Entity Analysis Overview:\\n\\nESTABLISHED PATTERNS:\\n1. BaseEntity inheritance with CRUD operations\\n2. Constructor: __init__(self, client, entity_name)\\n3. Business methods: 10-15+ specialized methods beyond CRUD\\n4. Field naming: Autotask CamelCase (AccountID, ProjectName)\\n5. Filters: Use QueryFilter for complex queries\\n6. Types: Dict, List, Optional, Any, Union from typing\\n7. Return types: EntityDict, List[EntityDict], or typed data\\n8. Relationships: Standard field naming (projectID, accountID)\\n9. Dates: ISO format strings\\n10. Status filtering: Map status names to IDs\\n\\nREQUIRED IMPORTS:\\n- from typing import Dict, List, Optional, Any, Union\\n- from datetime import datetime\\n- from decimal import Decimal (for financial calculations)\\n- from ..types import EntityDict, QueryFilter\\n- from .base import BaseEntity\\n\\nWEEK 4 ENTITIES TO ANALYZE:\\n1. ProjectPhasesEntity - project phase mgmt & milestone tracking\\n2. ProjectMilestonesEntity - key achievement & deadline tracking\\n3. AllocationCodesEntity - resource allocation & time categorization\\n4. HolidaySetsEntity - holiday calendar mgmt for resource planning\\n5. WorkflowRulesEntity - workflow automation rules & triggers\\n6. ProjectTemplatesEntity - project template mgmt & instantiation\\n7. ResourceAllocationEntity - resource assignment & capacity planning\\n8. ProjectBudgetsEntity - project budget tracking & variance analysis\\n9. TaskDependenciesEntity - task relationship & dependency mgmt\\n10. ProjectReportsEntity - project reporting & analytics framework\"",
      "type": "string",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-23T22:03:25.366Z",
      "updatedAt": "2025-06-23T22:03:25.366Z",
      "lastAccessedAt": "2025-06-23T22:03:25.366Z",
      "version": 1,
      "size": 1601,
      "compressed": true,
      "checksum": "e684c311386523399f48a8adf3663349a3d7ed3596255ecc2f633baca9892357",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mc9n8mq4_v7ect7dhg",
      "key": "swarm-auto-centralized-1750716058662/analyst/project_phases_entity",
      "value": "\"ProjectPhasesEntity Analysis:\\n\\nPURPOSE: Project phase management & milestone tracking\\n\\nCORE BUSINESS METHODS (15):\\n1. create_project_phase(project_id, phase_name, start_date, end_date, **kwargs) -> EntityDict\\n2. get_phases_by_project(project_id, status_filter=None, limit=None) -> List[EntityDict]\\n3. get_phase_by_name(project_id, phase_name) -> Optional[EntityDict]\\n4. update_phase_status(phase_id, status, completion_percentage=None) -> EntityDict\\n5. complete_phase(phase_id, actual_end_date=None, completion_notes=None) -> EntityDict\\n6. get_active_phases(project_id=None, limit=None) -> List[EntityDict] \\n7. get_overdue_phases(project_id=None, limit=None) -> List[EntityDict]\\n8. get_phases_by_status(status, project_id=None, limit=None) -> List[EntityDict]\\n9. assign_phase_resources(phase_id, resource_ids) -> List[EntityDict]\\n10. get_phase_milestones(phase_id) -> List[EntityDict]\\n11. calculate_phase_progress(phase_id) -> Dict[str, Any]\\n12. get_predecessor_phases(phase_id) -> List[EntityDict]\\n13. get_successor_phases(phase_id) -> List[EntityDict]\\n14. bulk_update_phase_status(phase_ids, status) -> List[EntityDict]\\n15. clone_phase_template(template_phase_id, target_project_id, **overrides) -> EntityDict\\n\\nFIELD DEFINITIONS:\\n- id: int (Primary Key)\\n- projectID: int (Foreign Key to Projects)\\n- phaseName: str (Required, max 255)\\n- description: Optional[str] (max 2000)\\n- startDate: str ISO format (Required)\\n- endDate: str ISO format (Required)\\n- actualStartDate: Optional[str] ISO format\\n- actualEndDate: Optional[str] ISO format\\n- status: int (1=Planned, 2=Active, 3=On Hold, 4=Complete, 5=Cancelled)\\n- completionPercentage: Optional[Decimal] (0-100)\\n- estimatedHours: Optional[Decimal]\\n- actualHours: Optional[Decimal]\\n- phaseOrder: int (Sequence within project)\\n- predecessorPhaseID: Optional[int] (Self-reference)\\n- milestoneCount: Optional[int] (Calculated)\\n- resourceCount: Optional[int] (Calculated)\\n- budgetAmount: Optional[Decimal]\\n- actualCost: Optional[Decimal]\\n- notes: Optional[str]\\n- createdDateTime: str ISO format\\n- lastModifiedDateTime: str ISO format\\n- createdBy: int (Resource ID)\\n- lastModifiedBy: int (Resource ID)\\n\\nRELATIONSHIPS:\\n- Parent: Projects (projectID)\\n- Children: ProjectMilestones (phaseID), Tasks (phaseID), TimeEntries (phaseID)\\n- Self-Reference: predecessorPhaseID for phase dependencies\\n\\nDATA TYPES:\\nfrom typing import Dict, List, Optional, Any, Union\\nfrom datetime import datetime\\nfrom decimal import Decimal\\nfrom ..types import EntityDict, QueryFilter\\nfrom .base import BaseEntity\\n\\nVALIDATION REQUIREMENTS:\\n- phaseName must be unique within project\\n- startDate must be <= endDate\\n- actualStartDate must be >= startDate if provided\\n- actualEndDate must be >= actualStartDate if provided  \\n- completionPercentage must be 0-100\\n- status transitions follow business rules\\n- phaseOrder must be unique within project\\n- predecessorPhaseID cannot create circular dependencies\"",
      "type": "string",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-23T22:03:47.596Z",
      "updatedAt": "2025-06-23T22:03:47.596Z",
      "lastAccessedAt": "2025-06-23T22:03:47.596Z",
      "version": 1,
      "size": 3079,
      "compressed": true,
      "checksum": "9ffc7dd4181cacf2a41fb06ea4e105f30552f1c7aa2f1b93cbdd484b51730354",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mc9n97kg_i62sf5j5q",
      "key": "swarm-auto-centralized-1750716058662/analyst/project_milestones_entity",
      "value": "\"ProjectMilestonesEntity Analysis:\\n\\nPURPOSE: Key achievement & deadline tracking\\n\\nCORE BUSINESS METHODS (15):\\n1. create_milestone(project_id, milestone_name, due_date, phase_id=None, **kwargs) -> EntityDict\\n2. get_milestones_by_project(project_id, status_filter=None, limit=None) -> List[EntityDict]\\n3. get_milestones_by_phase(phase_id, status_filter=None, limit=None) -> List[EntityDict]\\n4. update_milestone_status(milestone_id, status, completion_date=None) -> EntityDict\\n5. complete_milestone(milestone_id, actual_completion_date=None, completion_notes=None) -> EntityDict\\n6. get_upcoming_milestones(days_ahead=30, project_id=None, limit=None) -> List[EntityDict]\\n7. get_overdue_milestones(project_id=None, limit=None) -> List[EntityDict]\\n8. get_critical_path_milestones(project_id) -> List[EntityDict]\\n9. get_milestones_by_resource(resource_id, include_completed=False, limit=None) -> List[EntityDict]\\n10. calculate_milestone_variance(milestone_id) -> Dict[str, Any]\\n11. get_milestone_dependencies(milestone_id) -> List[EntityDict]\\n12. bulk_update_milestone_dates(milestone_ids, date_offset_days) -> List[EntityDict]\\n13. get_milestone_timeline(project_id, include_phases=True) -> List[EntityDict]\\n14. check_milestone_feasibility(milestone_id) -> Dict[str, Any]\\n15. clone_milestone_from_template(template_milestone_id, target_project_id, **overrides) -> EntityDict\\n\\nFIELD DEFINITIONS:\\n- id: int (Primary Key)\\n- projectID: int (Foreign Key to Projects, Required)\\n- phaseID: Optional[int] (Foreign Key to ProjectPhases)\\n- milestoneName: str (Required, max 255)\\n- description: Optional[str] (max 2000)\\n- dueDate: str ISO format (Required)\\n- actualCompletionDate: Optional[str] ISO format\\n- status: int (1=Planned, 2=In Progress, 3=Complete, 4=On Hold, 5=Cancelled)\\n- priority: int (1=Critical, 2=High, 3=Medium, 4=Low)\\n- milestoneType: int (1=Deliverable, 2=Review, 3=Approval, 4=Payment, 5=Go-Live)\\n- assignedResourceID: Optional[int] (Foreign Key to Resources)\\n- completionCriteria: Optional[str] (max 1000)\\n- deliverableDescription: Optional[str] (max 2000)\\n- isClientVisible: bool (Default: True)\\n- isCriticalPath: bool (Default: False)\\n- estimatedEffort: Optional[Decimal] (in hours)\\n- actualEffort: Optional[Decimal] (in hours)\\n- budgetAmount: Optional[Decimal]\\n- actualCost: Optional[Decimal]\\n- dependencyCount: Optional[int] (Calculated)\\n- riskLevel: int (1=Low, 2=Medium, 3=High, 4=Critical)\\n- completionPercentage: Optional[Decimal] (0-100)\\n- notes: Optional[str]\\n- createdDateTime: str ISO format\\n- lastModifiedDateTime: str ISO format\\n- createdBy: int (Resource ID)\\n- lastModifiedBy: int (Resource ID)\\n\\nRELATIONSHIPS:\\n- Parent: Projects (projectID)\\n- Parent: ProjectPhases (phaseID) - Optional\\n- Reference: Resources (assignedResourceID)\\n- Children: Tasks (milestoneID), MilestoneDependencies (milestoneID)\\n\\nDATA TYPES:\\nfrom typing import Dict, List, Optional, Any, Union\\nfrom datetime import datetime, timedelta\\nfrom decimal import Decimal\\nfrom ..types import EntityDict, QueryFilter\\nfrom .base import BaseEntity\\n\\nVALIDATION REQUIREMENTS:\\n- milestoneName must be unique within project\\n- dueDate must be within project date range\\n- actualCompletionDate must be >= project start date if provided\\n- completionPercentage must be 0-100\\n- priority must be 1-4\\n- milestoneType must be 1-5\\n- status transitions follow milestone lifecycle rules\\n- If phaseID provided, milestone must fall within phase dates\\n- estimatedEffort and actualEffort must be positive\\n- budgetAmount and actualCost must be positive\"",
      "type": "string",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-23T22:04:14.608Z",
      "updatedAt": "2025-06-23T22:04:14.608Z",
      "lastAccessedAt": "2025-06-23T22:04:14.608Z",
      "version": 1,
      "size": 3688,
      "compressed": true,
      "checksum": "9c2d55ecba8a214d651607fde50455e0bba203aa80310b7e918f3d7755f8efac",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mc9n9rcb_k32p4s4lv",
      "key": "swarm-auto-centralized-1750716058662/analyst/allocation_codes_entity",
      "value": "\"AllocationCodesEntity Analysis:\\n\\nPURPOSE: Resource allocation & time categorization\\n\\nCORE BUSINESS METHODS (15):\\n1. create_allocation_code(code_name, description, allocation_type, **kwargs) -> EntityDict\\n2. get_allocation_codes_by_type(allocation_type, is_active=True, limit=None) -> List[EntityDict]\\n3. get_active_allocation_codes(limit=None) -> List[EntityDict]\\n4. get_allocation_code_by_name(code_name) -> Optional[EntityDict]\\n5. update_allocation_code_status(code_id, is_active) -> EntityDict\\n6. get_allocation_usage_stats(code_id, date_range=None) -> Dict[str, Any]\\n7. get_allocation_codes_by_department(department_id, limit=None) -> List[EntityDict]\\n8. get_billable_allocation_codes(limit=None) -> List[EntityDict]\\n9. get_non_billable_allocation_codes(limit=None) -> List[EntityDict]\\n10. assign_allocation_code_to_project(code_id, project_id) -> EntityDict\\n11. get_project_allocation_codes(project_id, limit=None) -> List[EntityDict]\\n12. calculate_allocation_utilization(code_id, date_range) -> Dict[str, Any]\\n13. get_allocation_codes_by_resource(resource_id, date_range=None, limit=None) -> List[EntityDict]\\n14. bulk_update_allocation_rates(code_ids, rate_multiplier) -> List[EntityDict]\\n15. clone_allocation_code(source_code_id, new_name, **overrides) -> EntityDict\\n\\nFIELD DEFINITIONS:\\n- id: int (Primary Key)\\n- allocationCodeName: str (Required, max 100, Unique)\\n- description: Optional[str] (max 500)\\n- allocationType: int (1=Direct, 2=Indirect, 3=Overhead, 4=Administrative)\\n- isActive: bool (Default: True)\\n- isBillable: bool (Default: True)\\n- isDefault: bool (Default: False)\\n- departmentID: Optional[int] (Foreign Key to Departments)\\n- costCenter: Optional[str] (max 50)\\n- glAccount: Optional[str] (max 50, General Ledger Account)\\n- hourlyRate: Optional[Decimal] (Override default rates)\\n- rateMultiplier: Optional[Decimal] (Default: 1.0)\\n- minimumHours: Optional[Decimal] (Minimum time increment)\\n- maximumHours: Optional[Decimal] (Maximum daily hours)\\n- requiresApproval: bool (Default: False)\\n- approverResourceID: Optional[int] (Foreign Key to Resources)\\n- projectID: Optional[int] (Foreign Key to Projects, if project-specific)\\n- contractID: Optional[int] (Foreign Key to Contracts, if contract-specific)\\n- externalCode: Optional[str] (max 50, External system reference)\\n- sortOrder: int (Default: 0)\\n- usageCount: Optional[int] (Calculated field)\\n- totalHours: Optional[Decimal] (Calculated field)\\n- lastUsedDate: Optional[str] ISO format (Calculated field)\\n- notes: Optional[str]\\n- createdDateTime: str ISO format\\n- lastModifiedDateTime: str ISO format\\n- createdBy: int (Resource ID)\\n- lastModifiedBy: int (Resource ID)\\n\\nRELATIONSHIPS:\\n- Parent: Departments (departmentID) - Optional\\n- Parent: Projects (projectID) - Optional\\n- Parent: Contracts (contractID) - Optional\\n- Reference: Resources (approverResourceID) - Optional\\n- Children: TimeEntries (allocationCodeID), ProjectCharges (allocationCodeID)\\n\\nDATA TYPES:\\nfrom typing import Dict, List, Optional, Any, Union\\nfrom datetime import datetime, timedelta\\nfrom decimal import Decimal\\nfrom ..types import EntityDict, QueryFilter\\nfrom .base import BaseEntity\\n\\nVALIDATION REQUIREMENTS:\\n- allocationCodeName must be unique across all allocation codes\\n- allocationType must be 1-4\\n- hourlyRate must be positive if provided\\n- rateMultiplier must be positive (typically 0.5-3.0)\\n- minimumHours must be <= maximumHours if both provided\\n- Only one allocation code can be isDefault=True per type\\n- If requiresApproval=True, approverResourceID must be provided\\n- If projectID provided, allocation code is project-specific\\n- If contractID provided, allocation code is contract-specific\\n- sortOrder used for display ordering\\n- glAccount must match valid GL account format if provided\"",
      "type": "string",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-23T22:04:40.235Z",
      "updatedAt": "2025-06-23T22:04:40.235Z",
      "lastAccessedAt": "2025-06-23T22:04:40.235Z",
      "version": 1,
      "size": 3930,
      "compressed": true,
      "checksum": "a6951434ae7e14cc11c7b6575f45beeb20e85c73cd7b362021bd1867b0f6bb49",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mc9nacs8_97svaivxk",
      "key": "swarm-auto-centralized-1750716058662/analyst/holiday_sets_entity",
      "value": "\"HolidaySetsEntity Analysis:\\n\\nPURPOSE: Holiday calendar management for resource planning\\n\\nCORE BUSINESS METHODS (15):\\n1. create_holiday_set(set_name, description, country_code=None, **kwargs) -> EntityDict\\n2. add_holiday_to_set(set_id, holiday_name, holiday_date, is_recurring=False, **kwargs) -> EntityDict\\n3. remove_holiday_from_set(set_id, holiday_id) -> bool\\n4. get_holiday_sets_by_country(country_code, is_active=True, limit=None) -> List[EntityDict]\\n5. get_holidays_in_set(set_id, year=None, limit=None) -> List[EntityDict]\\n6. get_holidays_by_date_range(set_id, start_date, end_date) -> List[EntityDict]\\n7. check_if_holiday(set_id, check_date) -> bool\\n8. get_next_business_day(set_id, from_date) -> str\\n9. calculate_business_days(set_id, start_date, end_date) -> int\\n10. assign_holiday_set_to_resource(set_id, resource_id) -> EntityDict\\n11. get_resources_by_holiday_set(set_id, limit=None) -> List[EntityDict]\\n12. clone_holiday_set(source_set_id, new_name, target_year=None) -> EntityDict\\n13. import_holiday_template(template_name, year, country_code) -> EntityDict\\n14. get_upcoming_holidays(set_id, days_ahead=30) -> List[EntityDict]\\n15. bulk_update_holiday_dates(set_id, year_offset) -> List[EntityDict]\\n\\nFIELD DEFINITIONS:\\n- id: int (Primary Key)\\n- holidaySetName: str (Required, max 100)\\n- description: Optional[str] (max 500)\\n- countryCode: Optional[str] (max 3, ISO country code)\\n- isActive: bool (Default: True)\\n- isDefault: bool (Default: False)\\n- timeZone: Optional[str] (max 50, IANA timezone)\\n- yearApplicable: Optional[int] (Specific year, or null for all years)\\n- includeWeekends: bool (Default: True)\\n- customWorkWeek: Optional[str] (JSON format: weekday overrides)\\n- holidayCount: Optional[int] (Calculated field)\\n- resourceCount: Optional[int] (Calculated field)\\n- lastUsedDate: Optional[str] ISO format (Calculated field)\\n- notes: Optional[str]\\n- createdDateTime: str ISO format\\n- lastModifiedDateTime: str ISO format\\n- createdBy: int (Resource ID)\\n- lastModifiedBy: int (Resource ID)\\n\\nHOLIDAY DETAIL FIELDS (Related entity):\\n- holidayID: int (Primary Key)\\n- holidaySetID: int (Foreign Key)\\n- holidayName: str (Required, max 100)\\n- holidayDate: str ISO format (Required)\\n- isRecurring: bool (Default: False)\\n- recurrencePattern: Optional[str] (JSON format for recurring rules)\\n- holidayType: int (1=National, 2=Regional, 3=Religious, 4=Corporate, 5=Personal)\\n- isFloating: bool (Default: False, for holidays that change dates)\\n- observedDate: Optional[str] ISO format (Actual observed date if different)\\n- description: Optional[str] (max 500)\\n\\nRELATIONSHIPS:\\n- Children: HolidayDetails (holidaySetID)\\n- Reference: Resources (via ResourceHolidaySet junction table)\\n- Reference: Countries (countryCode)\\n\\nDATA TYPES:\\nfrom typing import Dict, List, Optional, Any, Union\\nfrom datetime import datetime, timedelta, date\\nfrom decimal import Decimal\\nfrom ..types import EntityDict, QueryFilter\\nfrom .base import BaseEntity\\n\\nVALIDATION REQUIREMENTS:\\n- holidaySetName must be unique\\n- countryCode must be valid ISO 3166-1 alpha-3 code if provided\\n- Only one holiday set can be isDefault=True per country\\n- timeZone must be valid IANA timezone identifier\\n- yearApplicable must be current year or future if provided\\n- holidayDate must be valid date\\n- recurrencePattern must be valid JSON if provided\\n- isRecurring holidays require valid recurrencePattern\\n- Holiday names must be unique within a holiday set\\n- observedDate must be within reasonable range of holidayDate\"",
      "type": "string",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-23T22:05:08.024Z",
      "updatedAt": "2025-06-23T22:05:08.024Z",
      "lastAccessedAt": "2025-06-23T22:05:08.024Z",
      "version": 1,
      "size": 3661,
      "compressed": true,
      "checksum": "cdeba0d23236a48289600f5dde752a15a76a1ca432b6ec965ff9a9398aaae801",
      "references": [],
      "dependencies": []
    },
    {
      "id": "entry_mc9nb0kx_10txpxmzw",
      "key": "swarm-auto-centralized-1750716058662/analyst/workflow_rules_entity",
      "value": "\"WorkflowRulesEntity Analysis:\\n\\nPURPOSE: Workflow automation rules & triggers\\n\\nCORE BUSINESS METHODS (15):\\n1. create_workflow_rule(rule_name, entity_type, trigger_event, **kwargs) -> EntityDict\\n2. add_rule_condition(rule_id, field_name, operator, value, **kwargs) -> EntityDict\\n3. add_rule_action(rule_id, action_type, action_config, **kwargs) -> EntityDict\\n4. activate_workflow_rule(rule_id) -> EntityDict\\n5. deactivate_workflow_rule(rule_id) -> EntityDict\\n6. get_workflow_rules_by_entity(entity_type, is_active=True, limit=None) -> List[EntityDict]\\n7. get_workflow_rules_by_trigger(trigger_event, entity_type=None, limit=None) -> List[EntityDict]\\n8. test_workflow_rule(rule_id, test_data) -> Dict[str, Any]\\n9. execute_workflow_rule(rule_id, entity_id, context_data=None) -> Dict[str, Any]\\n10. get_rule_execution_history(rule_id, limit=100) -> List[EntityDict]\\n11. get_workflow_rule_conditions(rule_id) -> List[EntityDict]\\n12. get_workflow_rule_actions(rule_id) -> List[EntityDict]\\n13. clone_workflow_rule(source_rule_id, new_name, **overrides) -> EntityDict\\n14. bulk_activate_rules(rule_ids) -> List[EntityDict]\\n15. get_failed_workflow_executions(date_range=None, limit=100) -> List[EntityDict]\\n\\nFIELD DEFINITIONS:\\n- id: int (Primary Key)\\n- workflowRuleName: str (Required, max 100)\\n- description: Optional[str] (max 1000)\\n- entityType: str (Required, max 50, e.g., 'Tickets', 'Projects')\\n- triggerEvent: str (Required, max 50, e.g., 'Create', 'Update', 'StatusChange')\\n- isActive: bool (Default: False)\\n- priority: int (1-10, higher number = higher priority, Default: 5)\\n- executionOrder: int (For rules with same priority, Default: 0)\\n- conditionLogic: str (Default: 'AND', Options: 'AND', 'OR', 'CUSTOM')\\n- customLogicExpression: Optional[str] (max 500, for complex condition logic)\\n- executeOnce: bool (Default: False, prevent multiple executions)\\n- maxExecutions: Optional[int] (Limit executions per entity)\\n- executionTimeout: int (Seconds, Default: 30)\\n- isRecursive: bool (Default: False, allow recursive triggers)\\n- lastExecutedDateTime: Optional[str] ISO format (Calculated)\\n- executionCount: Optional[int] (Calculated)\\n- successCount: Optional[int] (Calculated)\\n- failureCount: Optional[int] (Calculated)\\n- avgExecutionTime: Optional[Decimal] (Milliseconds, Calculated)\\n- notes: Optional[str]\\n- createdDateTime: str ISO format\\n- lastModifiedDateTime: str ISO format\\n- createdBy: int (Resource ID)\\n- lastModifiedBy: int (Resource ID)\\n\\nRULE CONDITION FIELDS (Related entity):\\n- conditionID: int (Primary Key)\\n- workflowRuleID: int (Foreign Key)\\n- fieldName: str (Required, max 100)\\n- operator: str (Required, max 20, e.g., 'equals', 'contains', 'greater_than')\\n- value: Optional[str] (max 500, condition value)\\n- valueType: str (Default: 'static', Options: 'static', 'field', 'function')\\n- conditionGroup: int (Default: 1, for grouping conditions)\\n- isNegated: bool (Default: False)\\n- sortOrder: int (Default: 0)\\n\\nRULE ACTION FIELDS (Related entity):\\n- actionID: int (Primary Key)\\n- workflowRuleID: int (Foreign Key)\\n- actionType: str (Required, max 50, e.g., 'UpdateField', 'SendEmail', 'CreateTask')\\n- actionConfig: str (Required, JSON format configuration)\\n- executeOrder: int (Default: 0)\\n- isEnabled: bool (Default: True)\\n- retryCount: int (Default: 0)\\n- maxRetries: int (Default: 3)\\n\\nRELATIONSHIPS:\\n- Children: WorkflowRuleConditions (workflowRuleID), WorkflowRuleActions (workflowRuleID), WorkflowExecutionLog (workflowRuleID)\\n- Reference: Various entities based on entityType\\n\\nDATA TYPES:\\nfrom typing import Dict, List, Optional, Any, Union\\nfrom datetime import datetime, timedelta\\nfrom decimal import Decimal\\nimport json\\nfrom ..types import EntityDict, QueryFilter\\nfrom .base import BaseEntity\\n\\nVALIDATION REQUIREMENTS:\\n- workflowRuleName must be unique\\n- entityType must be valid Autotask entity name\\n- triggerEvent must be valid for the entity type\\n- priority must be 1-10\\n- conditionLogic must be 'AND', 'OR', or 'CUSTOM'\\n- If conditionLogic='CUSTOM', customLogicExpression is required\\n- executionTimeout must be 1-300 seconds\\n- operator must be valid for field data type\\n- actionConfig must be valid JSON\\n- executeOrder determines action sequence\\n- Recursive workflows must have safeguards against infinite loops\"",
      "type": "string",
      "namespace": "default",
      "tags": [],
      "metadata": {},
      "owner": "system",
      "accessLevel": "shared",
      "createdAt": "2025-06-23T22:05:38.865Z",
      "updatedAt": "2025-06-23T22:05:38.865Z",
      "lastAccessedAt": "2025-06-23T22:05:38.865Z",
      "version": 1,
      "size": 4451,
      "compressed": true,
      "checksum": "0c24aa88a270831d5547675be0ec719f59032c902ef56c7bc8381bf67319834d",
      "references": [],
      "dependencies": []
    }
  ],
  "statistics": {
    "overview": {
      "totalEntries": 6,
      "totalSize": 20410,
      "compressedEntries": 6,
      "compressionRatio": 0,
      "indexSize": 300,
      "memoryUsage": 9152992,
      "diskUsage": 0
    },
    "distribution": {
      "byNamespace": {
        "default": {
          "count": 6,
          "size": 20410
        }
      },
      "byType": {
        "string": {
          "count": 6,
          "size": 20410
        }
      },
      "byOwner": {
        "system": {
          "count": 6,
          "size": 20410
        }
      },
      "byAccessLevel": {
        "shared": {
          "count": 6,
          "size": 20410
        }
      }
    },
    "temporal": {
      "entriesCreatedLast24h": 6,
      "entriesUpdatedLast24h": 6,
      "entriesAccessedLast24h": 6,
      "oldestEntry": "2025-06-23T22:03:25.366Z",
      "newestEntry": "2025-06-23T22:05:38.865Z"
    },
    "performance": {
      "averageQueryTime": 0,
      "averageWriteTime": 0,
      "cacheHitRatio": 0,
      "indexEfficiency": 0.95
    },
    "health": {
      "expiredEntries": 0,
      "orphanedReferences": 0,
      "duplicateKeys": 0,
      "corruptedEntries": 0,
      "recommendedCleanup": false
    },
    "optimization": {
      "suggestions": [],
      "potentialSavings": {
        "compression": 0,
        "cleanup": 0,
        "deduplication": 0
      },
      "indexOptimization": [
        "Consider periodic index rebuilding for optimal performance"
      ]
    }
  }
}